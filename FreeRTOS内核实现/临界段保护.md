### 存储器屏障指令(DMB,DSB,ISB)

对于ARM架构，包括(ARMv7-M 在内)，在不影响数据处理 结果的情况下，存储器传输的顺序可以和程序代码不同。这种特性也叫乱序执行

#### (1) Data Memory Barrier (DMB):数据存储器屏障

确保在**执行新的存储器访问前**，所有的存储器访问都已完成

使用CMSIS函数库代码为

```C
void __DMB(void); //数据存储器屏障
```

#### (2) Data Synchronization Barrier(DSB):数据同步屏障

确保在**下一条指令执行前**所有的存储器访问都已经完成，它确保在`DSB`之前的所有显式数据内存传输指令都已经在内存中读取或写入完成，同时确保任何后续的指令都将在`DSB`执行之后开始执行

```C
void __DSB(void); //数据同步屏障
```

#### (3) Instruction Synchronization Barrier(ISB):指令同步屏障

清空流水线，确保在**执行新的指令前**，之前所有的指令都已完成

```c
void __ISB(void); //指令同步屏障
```



## 临界段的保护

#### 什么是临界段

就是一段 执行时不能被中断所打断的代码段。

什么时候在执行临界段，会有中断到达呢？一个是系统调度，另一个是外部中断，而系统调度本质也是产生一个PendSV中断，在PendSV Handler 里面实现任务的切换，所以两者归根结底都是中断，对于临界段的效果如何实现，**就是要实现对于中断的开关控制**

#### 临界段代码实现

1. 开中断函数，**分别有中断保护，和不带中断保护的版本**
2. 关中断函数，**分别有不可以在中断中嵌套的版本，和可以在中断中嵌套的版本**
3. 进入临界段函数，**分别带中断保护和不带中断保护的版本**
4. 退出临界段函数，**分别分带中断保护和不带中断保护的版本**

#### 关中断

```c
//portmacro.h定义 

/*不带返回值的关闭中断函数，不能嵌套，不能在中断里面使用*/
#define portDISABLE_INTERRUPTS() vPortRaiseBASEPRI()
/*带返回值的关中断函数，可以嵌套，可以在中断中使用*/
#define portSET_INTERRUPT_MASK_FROM_ISR() ulPortRasieBASEPRI()

/// @brief 不带返回值的关部分中断的函数
/// @details 它将 BASEPRI 寄存器的值设置为 configMAX_SYSCALL_INTERRUPT_PRIORITY，并不理睬当前在中断状态
static portFORCE_INLINE void vPortRaiseBASEPRI(void)
{
    uint32_t ulNewBASEPRI = configMAX_SYSCALL_INTERRUPT_PRIORITY;
    __asm
    {
          msr basepri, ulNewBASEPRI
          dsb
          isb
    }
}

/// @brief 带有返回值的关部分中断的函数
/// @details 它将 BASEPRI 寄存器的值设置为 configMAX_SYSCALL_INTERRUPT_PRIORITY，并返回当前 BASEPRI 寄存器的值
static portFORCE_INLINE uint32_t ulPortRasieBASEPRI (void)
{
    uint32_t ulReturn, ulNewBASEPRI = configMAX_SYSCALL_INTERRUPT_PRIORITY;
    __asm
    {
          mrs ulReturn, basepri
          msr basepri, ulNewBASEPRI
          dsb
          isb
    }
    return ulReturn;
}

```

总结：

关中断函数，通过**写入 CortexM3 内核的 BASEPRI 寄存器**

至于能不能实现中断嵌套，则得看在写入 BASEPRI 寄存器的时候，**能不能保存当前BASEPRI寄存器的值，如果不保存，则不管当前中断状态，也就意味着不能在中断当中使用**



#### 开中断

```C
/*不带中断保护的开中断函数*/
#define portENABLE_INTERRUPTS() vPortSetBASEPRI(0)
/*带中断保护的开中断函数*/
#define portCLEAR_INTERRUPT_MASK_FROM_ISR(x) vPortSetBASEPRI(x)

/// @brief 设置 BASEPRI 寄存器的值
/// @param ulBASEPRI  要设置的 BASEPRI 值
/// @return void
static portFORCE_INLINE void vPortSetBASEPRI( uint32_t ulBASEPRI )
{
    __asm
    {
          msr basepri, ulBASEPRI
    }
}

```

开中断函数，具体是**将传入的形参更新到BASEPRI 寄存器**，根据传入的形参不同，**分为中断保护版本和非中断保护版本** 



#### 进入/退出临界段的宏

```c
/*进入和退出临界段宏定义 task.h*/

/*进入临界段，不带中断保护版本*/
#define taskENTER_CRITICAL()   portENTER_CRITICAL()
/*进入临界段，带中断保护版本*/
#define taskENTER_CRITICAL_FROM_ISR()   portSET_INTERRUPT_MASK_FROM_ISR()


/*退出临界段 task.h*/
/*退出临界段，不带中断恢复版本*/
#define taskEXIT_CRITICAL()    portEXIT_CRITICAL()
/*退出临界段，带中断恢复版本*/
#define taskEXIT_CRITICAL_FROM_ISR(x)   portCLEAR_INTERRUPT_MASK_FROM_ISR(x)


/*进入临界段，不带中断保护版本，不能嵌套*/
#define portENTER_CRITICAL()  vPortEnterCritical()
/*退出临界段，不带中断保护版本，不能嵌套*/
#define portEXIT_CRITICAL()   vPortExitCritical()
```

进入和退出临界段的宏，都有中断保护版本和非中断版本，但最终都是通过开/关中断实现



#### 进入临界段函数实现

![image-20250603130536377](https://mrzhb.oss-cn-chengdu.aliyuncs.com/image-20250603130536377.png)

```C
/*进入临界段的不带中断保护的版本的函数*/
void vPortEnterCritical(void)
{   
    /*关中断*/
    portDISABLE_INTERRUPTS();
    uxCriticalNesting++;

    if(uxCriticalNesting == 1)
    {
        //configASSERT((portNVIC_INT_CTRL_REG & portVECTACTIVE_MASK) == 0);
    }
}

```

和进入临界段带中断保护的版本

![image-20250603131147197](https://mrzhb.oss-cn-chengdu.aliyuncs.com/image-20250603131147197.png)

相当于直接调用可以嵌套的中断保护，也就是直接**使用了函数没有其他多余的实现**

#### 退出临界段

```C
/*退出临界段的不带中断保护的版本的函数*/
void vPortExitCritical(void)
{
    //configASSERT( uxCriticalNesting);
    uxCriticalNesting--;
    if(uxCriticalNesting == 0){
        portENABLE_INTERRUPTS();
    }
}

```

这个临界段函数是不能嵌套的

##### 带中断保护的版本可以嵌套

![image-20250603131800007](https://mrzhb.oss-cn-chengdu.aliyuncs.com/image-20250603131800007.png)





























